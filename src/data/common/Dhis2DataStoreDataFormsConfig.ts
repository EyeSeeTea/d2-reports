import _ from "lodash";
import { D2Api } from "@eyeseetea/d2-api/2.34";
import { array, boolean, Codec, GetType, intersect, oneOf, optional, string } from "purify-ts";
import { dataStoreNamespace, Namespaces } from "./clients/storage/Namespaces";
import { Maybe, NonPartial } from "../../utils/ts-utils";
import { Id, NamedRef } from "../../domain/common/entities/Base";
import { Option } from "../../domain/common/entities/DataElement";

const selector = oneOf([
    Codec.interface({ id: string }),
    Codec.interface({ code: string }), //
]);

const DataStoreConfigCodec = Codec.interface({
    dataElements: optional(
        array(
            intersect(
                selector,
                Codec.interface({
                    selection: Codec.interface({
                        optionSet: selector,
                        isMultiple: boolean,
                    }),
                })
            )
        )
    ),
});

export interface DataElementConfig {
    selection?: {
        optionSet: OptionSet;
        isMultiple: boolean;
    };
}

interface OptionSet extends NamedRef {
    code: string;
    options: Option<string>[];
}

export type Selector = GetType<typeof selector>;
type DataFormStoreConfigFromCodec = GetType<typeof DataStoreConfigCodec>;

interface DataFormStoreConfig {
    custom: NonPartial<DataFormStoreConfigFromCodec>;
    optionSets: OptionSet[];
}

const defaultDataStoreConfig: DataFormStoreConfig["custom"] = {
    dataElements: [],
};

export class Dhis2DataStoreDataForm {
    constructor(private config: DataFormStoreConfig) {}

    static async build(api: D2Api): Promise<Dhis2DataStoreDataForm> {
        const dataStore = api.dataStore(dataStoreNamespace);
        const storeValue = await dataStore.get<object>(Namespaces.AUTOGENERATED_FORMS).getData();
        if (!storeValue) return new Dhis2DataStoreDataForm({ optionSets: [], custom: defaultDataStoreConfig });

        const config: DataFormStoreConfig = await DataStoreConfigCodec.decode(storeValue).caseOf({
            Left: async errorMsg => {
                console.error("Cannot decode autogenerated forms config", {
                    value: storeValue,
                    error: errorMsg,
                });
                return { optionSets: [], custom: defaultDataStoreConfig };
            },
            Right: async storeConfigFromDataStore => {
                const storeConfig: DataFormStoreConfig["custom"] = {
                    dataElements: storeConfigFromDataStore.dataElements || defaultDataStoreConfig.dataElements,
                };
                const optionSetSelectors = storeConfig.dataElements?.map(de => de.selection.optionSet);
                const optionSets = await this.getOptionSets(api, optionSetSelectors || []);

                return { optionSets, custom: storeConfig };
            },
        });

        return new Dhis2DataStoreDataForm(config);
    }

    private static async getOptionSets(api: D2Api, selectors: Selector[]): Promise<OptionSet[]> {
        const ids = _.compact(selectors.map(selector => ("id" in selector ? selector.id : null)));
        const codes = _.compact(selectors.map(selector => ("code" in selector ? selector.code : null)));

        const fields = {
            id: true,
            name: true,
            code: true,
            options: { code: true, displayName: true },
        } as const;

        const res1 = _.isEmpty(ids)
            ? { optionSets: [] }
            : await api.metadata.get({ optionSets: { fields: fields, filter: { id: { in: ids } } } }).getData();

        const res2 = _.isEmpty(codes)
            ? { optionSets: [] }
            : await api.metadata.get({ optionSets: { fields: fields, filter: { code: { in: codes } } } }).getData();

        return _.concat(res1.optionSets, res2.optionSets).map(
            (optionSet): OptionSet => ({
                ...optionSet,
                options: optionSet.options.map(option => ({
                    name: option.displayName,
                    value: option.code,
                })),
            })
        );
    }

    getDataElementConfig(dataElement: { id: Id; code: string }): Maybe<DataElementConfig> {
        const dataElementStoreConfig = this.config.custom.dataElements.find(dataElementSelector =>
            selectorMatches(dataElement, dataElementSelector)
        );
        if (!dataElementStoreConfig) return;

        const optionSetSelector = dataElementStoreConfig.selection.optionSet;
        const optionSet = this.config.optionSets.find(optionSet => selectorMatches(optionSet, optionSetSelector));
        if (!optionSet) return;

        return {
            selection: {
                isMultiple: dataElementStoreConfig.selection.isMultiple,
                optionSet,
            },
        };
    }
}

function selectorMatches<T extends { id: string; code: string }>(obj: T, selector: Selector): boolean {
    return "id" in selector ? obj.id === selector.id : obj.code === selector.code;
}
