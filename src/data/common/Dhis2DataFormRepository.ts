import _ from "lodash";
import { Id } from "../../domain/common/entities/Base";
import { DataForm, Section, SubSection } from "../../domain/common/entities/DataForm";
import { DataElement, DataElementM } from "../../domain/common/entities/DataElement";
import { Period } from "../../domain/common/entities/DataValue";
import { DataFormRepository } from "../../domain/common/repositories/DataFormRepository";
import { D2Api, MetadataPick } from "../../types/d2-api";
import { isElementOfUnion, NonPartial } from "../../utils/ts-utils";
import { dataStoreNamespace, Namespaces } from "./clients/storage/Namespaces";
import { array, boolean, Codec, GetType, oneOf, optional, string } from "purify-ts";

/* Build DataForm objects from DHIS2 dataSet. It uses sections and " - " in dataElement.formName 
   as separator to group them in subsections. An example:
 *
 *    dataSet.section = ITNs. dataElements:
 *
 *    - ITNs - Basic - Written Policy
 *    - ITNs - Basic - Policy Implemented
 *    - ITNs - Extended - Written Policy
 *    - ITNs - Extended - Policy Implemented
 *
 *    This will create section ITNs:
 *
 *       - Subsection ITNs - Basic:
 *          - ITNs - Basic - Written Policy
 *          - ITNs - Basic - Policy Implemented
 *       - Subsection ITNs - Extended:
 *          - ITNs - Extended - Written Policy
 *          - ITNs - Extended - Policy Implemented
 *
 *   Further customization unsupported by DHIS2 is save in the dataStore (check type DataFormStoreConfig):
 *     - Data elements multi-selection populated from optionSet.
 **/

export class Dhis2DataFormRepository implements DataFormRepository {
    constructor(private api: D2Api) {}

    async get(options: { id: Id; orgUnitId: Id; period: Period }): Promise<DataForm> {
        const metadata = await this.getMetadata(options);
        const dataSet = metadata.dataSets[0];
        if (!dataSet) return Promise.reject(new Error("Data set not found"));
        const dataStoreConfig: DataFormConfig["custom"] = await this.getDataStoreConfig();

        const config: DataFormConfig = {
            custom: dataStoreConfig,
            optionSets: metadata.optionSets,
        };

        return {
            id: dataSet.id,
            sections: getSections(dataSet, config),
        };
    }

    private async getDataStoreConfig() {
        const dataStore = this.api.dataStore(dataStoreNamespace);
        const storeValue = await dataStore.get<object>(Namespaces.AUTOGENERATED_FORMS).getData();
        if (!storeValue) return defaultDataStoreConfig;

        return DataStoreConfigCodec.decode(storeValue).caseOf({
            Left: errorMsg => {
                console.error("Cannot decode autogenerated forms config", {
                    value: storeValue,
                    error: errorMsg,
                });
                return defaultDataStoreConfig;
            },
            Right: storeConfig => {
                return _.merge({}, defaultDataStoreConfig, storeConfig);
            },
        });
    }

    private async getMetadata(options: { id: Id }) {
        const metadataQuery = getMetadataQuery({ dataSetId: options.id });
        return this.api.metadata.get(metadataQuery).getData();
    }
}

interface DataFormConfig {
    custom: NonPartial<DataFormStoreConfig>;
    optionSets: D2OptionSet[];
}

type Metadata = ReturnType<typeof getMetadataQuery>;
type D2DataSet = MetadataPick<Metadata>["dataSets"][number];
type D2OptionSet = MetadataPick<Metadata>["optionSets"][number];
type D2DataElement = D2DataSet["sections"][number]["dataElements"][number];

const separator = " - ";

function getSections(dataSet: D2DataSet, config: DataFormConfig) {
    return dataSet.sections.map((section): Section => {
        return {
            id: section.id,
            name: section.displayName,
            subsections: _(section.dataElements)
                .groupBy(dataElement => _(dataElement.formName).split(separator).initial().join(separator))
                .toPairs()
                .map(
                    ([groupName, dataElementsForGroup]): SubSection =>
                        getSubsection(groupName, dataElementsForGroup, config)
                )
                .value(),
        };
    });
}

function getSubsection(name: string, dataElements: D2DataElement[], config: DataFormConfig): SubSection {
    return {
        name: name,
        dataElements: _(dataElements)
            .map((dataElement): DataElement | null => {
                const { valueType } = dataElement;
                const name = _(dataElement.formName).split(separator).last() || "-";
                const deConfig = config.custom.dataElements.find(de => selectorMatches(dataElement, de.selector));
                const deConfigSelection = deConfig?.selection;

                if (valueType === "TEXT") {
                    if (dataElement.optionSet) {
                        return {
                            valueType: "OPTION",
                            id: dataElement.id,
                            name,
                            options: dataElement.optionSet.options.map(option => ({
                                name: option.displayName,
                                value: option.code,
                            })),
                            // DHIS2 validates values with optionSet assigned (only one value)
                            isMultiple: false,
                        };
                    } else if (deConfigSelection) {
                        const optionSet = config.optionSets.find(optionSet =>
                            selectorMatches(optionSet, deConfigSelection.optionSet)
                        );
                        if (!optionSet) {
                            console.error(`Option set not found: ${deConfigSelection.optionSet}`);
                            return null;
                        }
                        return {
                            valueType: "OPTION",
                            id: dataElement.id,
                            name,
                            options: optionSet.options.map(option => ({
                                name: option.displayName,
                                value: option.code,
                            })),
                            isMultiple: deConfigSelection.isMultiple,
                        };
                    } else {
                        return {
                            ...dataElement,
                            valueType: "TEXT",
                            name,
                        };
                    }
                } else if (isElementOfUnion(valueType, DataElementM.valueTypesSupported)) {
                    return {
                        ...dataElement,
                        valueType,
                        name,
                    };
                } else {
                    console.error(
                        `Data element [formName=${dataElement.formName}, id=${dataElement.id}, valueType=${dataElement.valueType}] skipped, valueType not supported`
                    );
                    return null;
                }
            })
            .compact()
            .value(),
    };
}

function getMetadataQuery(options: { dataSetId: Id }) {
    return {
        dataSets: {
            fields: {
                id: true,
                sections: {
                    id: true,
                    displayName: true,
                    dataElements: {
                        id: true,
                        code: true,
                        formName: true,
                        valueType: true,
                        optionSet: {
                            id: true,
                            options: { id: true, displayName: true, code: true },
                        },
                    },
                },
            },
            filter: { id: { eq: options.dataSetId } },
        },
        optionSets: {
            fields: {
                id: true,
                code: true,
                options: { code: true, displayName: true },
            },
        },
    } as const;
}

/* Data store */

const selector = oneOf([Codec.interface({ id: string }), Codec.interface({ code: string })]);

const DataStoreConfigCodec = Codec.interface({
    dataElements: optional(
        array(
            Codec.interface({
                selector: selector,
                selection: Codec.interface({
                    optionSet: selector,
                    isMultiple: boolean,
                }),
            })
        )
    ),
});

type Selector = GetType<typeof selector>;
type DataFormStoreConfig = GetType<typeof DataStoreConfigCodec>;

const defaultDataStoreConfig: DataFormConfig["custom"] = {
    dataElements: [],
};

function selectorMatches<T extends { id: string; code: string }>(obj: T, selector: Selector): boolean {
    return "id" in selector ? obj.id === selector.id : obj.code === selector.code;
}
