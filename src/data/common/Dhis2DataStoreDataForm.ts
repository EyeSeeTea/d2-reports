import _ from "lodash";
import { D2Api } from "@eyeseetea/d2-api/2.34";
import { boolean, Codec, GetType, oneOf, optional, record, string } from "purify-ts";
import { dataStoreNamespace, Namespaces } from "./clients/storage/Namespaces";
import { isElementOfUnion, Maybe, NonPartial } from "../../utils/ts-utils";
import { Id, NamedRef } from "../../domain/common/entities/Base";
import { Option } from "../../domain/common/entities/DataElement";
import { DataFormM, ViewType } from "../../domain/common/entities/DataForm";

export interface DataSetConfig {
    texts: { header: string; footer: string };
    viewType: ViewType;
    sections: Record<Id, { viewType: ViewType }>;
}

function sectionConfig<T extends Record<string, Codec<any>>>(properties: T) {
    return optional(record(string, Codec.interface(properties)));
}

const selector = oneOf([
    Codec.interface({ id: string }),
    Codec.interface({ code: string }), //
]);

const DataStoreConfigCodec = Codec.interface({
    dataElements: sectionConfig({
        selection: optional(
            Codec.interface({
                optionSet: selector,
                isMultiple: boolean,
            })
        ),
    }),

    dataSets: sectionConfig({
        viewType: optional(string),
        texts: optional(
            Codec.interface({
                header: optional(string),
                footer: optional(string),
            })
        ),
        sections: optional(
            sectionConfig({
                viewType: optional(string),
            })
        ),
    }),
});

interface DataElementConfig {
    selection?: {
        optionSet: OptionSet;
        isMultiple: boolean;
    };
}

interface OptionSet extends NamedRef {
    code: string;
    options: Option<string>[];
}

type Selector = GetType<typeof selector>;
type DataFormStoreConfigFromCodec = GetType<typeof DataStoreConfigCodec>;

interface DataFormStoreConfig {
    custom: NonPartial<DataFormStoreConfigFromCodec>;
    optionSets: OptionSet[];
}

const defaultDataStoreConfig: DataFormStoreConfig["custom"] = {
    dataElements: {},
    dataSets: {},
};

interface DataSet {
    id: Id;
    code: string;
    sections: Array<{ id: string; code: string }>;
}

export class Dhis2DataStoreDataForm {
    constructor(private config: DataFormStoreConfig) {}

    static async build(api: D2Api): Promise<Dhis2DataStoreDataForm> {
        const dataStore = api.dataStore(dataStoreNamespace);
        const storeValue = await dataStore.get<object>(Namespaces.AUTOGENERATED_FORMS).getData();
        if (!storeValue) return new Dhis2DataStoreDataForm({ optionSets: [], custom: defaultDataStoreConfig });

        const config: DataFormStoreConfig = await DataStoreConfigCodec.decode(storeValue).caseOf({
            Left: async errorMsg => {
                console.error("Cannot decode autogenerated forms config", {
                    value: storeValue,
                    error: errorMsg,
                });
                return { optionSets: [], custom: defaultDataStoreConfig };
            },
            Right: async storeConfigFromDataStore => {
                const storeConfig: DataFormStoreConfig["custom"] = {
                    dataElements: storeConfigFromDataStore.dataElements || {},
                    dataSets: storeConfigFromDataStore.dataSets || {},
                };
                const optionSetsInConfig = _(storeConfig.dataElements)
                    .values()
                    .map(obj => obj.selection?.optionSet)
                    .compact()
                    .value();

                const optionSets = await this.getOptionSets(api, optionSetsInConfig || []);

                return { optionSets, custom: storeConfig };
            },
        });

        return new Dhis2DataStoreDataForm(config);
    }

    private static async getOptionSets(api: D2Api, selectors: Selector[]): Promise<OptionSet[]> {
        const ids = _.compact(selectors.map(selector => ("id" in selector ? selector.id : null)));
        const codes = _.compact(selectors.map(selector => ("code" in selector ? selector.code : null)));

        const fields = {
            id: true,
            name: true,
            code: true,
            options: { code: true, displayName: true },
        } as const;

        const resByIds = _.isEmpty(ids)
            ? { optionSets: [] }
            : await api.metadata.get({ optionSets: { fields: fields, filter: { id: { in: ids } } } }).getData();

        const resByCodes = _.isEmpty(codes)
            ? { optionSets: [] }
            : await api.metadata.get({ optionSets: { fields: fields, filter: { code: { in: codes } } } }).getData();

        return _.concat(resByIds.optionSets, resByCodes.optionSets).map(
            (optionSet): OptionSet => ({
                ...optionSet,
                options: optionSet.options.map(option => ({
                    name: option.displayName,
                    value: option.code,
                })),
            })
        );
    }

    getDataSetConfig(dataSet: DataSet): DataSetConfig {
        const dataSetConfig = this.config.custom.dataSets?.[dataSet.code];
        const viewType = dataSetConfig?.viewType;

        const sections = _(dataSetConfig?.sections)
            .toPairs()
            .map(([code, sectionConfig]) => {
                const section = dataSet.sections.find(section => section.code === code);
                return section
                    ? ([section.id, { viewType: getViewType(sectionConfig.viewType) }] as [Id, { viewType: ViewType }])
                    : undefined;
            })
            .compact()
            .fromPairs()
            .value();

        return {
            texts: {
                header: dataSetConfig?.texts?.header || "",
                footer: dataSetConfig?.texts?.footer || "",
            },
            viewType: getViewType(viewType),
            sections: sections,
        };
    }

    getDataElementConfig(dataElement: CodedRef): Maybe<DataElementConfig> {
        const dataElementConfig = this.config.custom.dataElements[dataElement.code];
        const optionSetSelector = dataElementConfig?.selection;
        if (!optionSetSelector) return;

        const optionSet = this.config.optionSets.find(optionSet =>
            selectorMatches(optionSet, optionSetSelector.optionSet)
        );
        if (!optionSet) return;

        return {
            selection: {
                isMultiple: optionSetSelector.isMultiple,
                optionSet,
            },
        };
    }
}

function getViewType(viewType: Maybe<string>): ViewType {
    return viewType && isElementOfUnion(viewType, DataFormM.viewTypes) ? viewType : "table";
}

function selectorMatches<T extends { id: string; code: string }>(obj: T, selector: Selector): boolean {
    return "id" in selector ? obj.id === selector.id : obj.code === selector.code;
}

type CodedRef = { id: Id; code: string };
