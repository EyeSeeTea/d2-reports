import _ from "lodash";
import { D2Api } from "@eyeseetea/d2-api/2.34";
import { array, boolean, Codec, GetType, intersect, oneOf, optional, string } from "purify-ts";
import { dataStoreNamespace, Namespaces } from "./clients/storage/Namespaces";
import { isElementOfUnion, Maybe, NonPartial } from "../../utils/ts-utils";
import { Id, NamedRef } from "../../domain/common/entities/Base";
import { Option } from "../../domain/common/entities/DataElement";
import { DataFormM, ViewType } from "../../domain/common/entities/DataForm";

interface DataSetConfig {
    texts: { header: string; footer: string };
    viewType: ViewType;
}

interface DataSetConfig {}

const selector = oneOf([
    Codec.interface({ id: string }),
    Codec.interface({ code: string }), //
]);

function listOf<T>(codec: Codec<T>) {
    return optional(array(intersect(selector, codec)));
}

const DataStoreConfigCodec = Codec.interface({
    dataElements: listOf(
        Codec.interface({
            selection: Codec.interface({
                optionSet: selector,
                isMultiple: boolean,
            }),
        })
    ),
    dataSets: listOf(
        Codec.interface({
            viewType: optional(string),
            texts: Codec.interface({
                header: optional(string),
                footer: optional(string),
            }),
        })
    ),
});

interface DataElementConfig {
    selection?: {
        optionSet: OptionSet;
        isMultiple: boolean;
    };
}

interface OptionSet extends NamedRef {
    code: string;
    options: Option<string>[];
}

type Selector = GetType<typeof selector>;
type DataFormStoreConfigFromCodec = GetType<typeof DataStoreConfigCodec>;

interface DataFormStoreConfig {
    custom: NonPartial<DataFormStoreConfigFromCodec>;
    optionSets: OptionSet[];
}

const defaultDataStoreConfig: DataFormStoreConfig["custom"] = {
    dataElements: [],
    dataSets: [],
};

export class Dhis2DataStoreDataForm {
    constructor(private config: DataFormStoreConfig) {}

    static async build(api: D2Api): Promise<Dhis2DataStoreDataForm> {
        const dataStore = api.dataStore(dataStoreNamespace);
        const storeValue = await dataStore.get<object>(Namespaces.AUTOGENERATED_FORMS).getData();
        if (!storeValue) return new Dhis2DataStoreDataForm({ optionSets: [], custom: defaultDataStoreConfig });

        const config: DataFormStoreConfig = await DataStoreConfigCodec.decode(storeValue).caseOf({
            Left: async errorMsg => {
                console.error("Cannot decode autogenerated forms config", {
                    value: storeValue,
                    error: errorMsg,
                });
                return { optionSets: [], custom: defaultDataStoreConfig };
            },
            Right: async storeConfigFromDataStore => {
                const storeConfig: DataFormStoreConfig["custom"] = {
                    dataElements: storeConfigFromDataStore.dataElements || [],
                    dataSets: storeConfigFromDataStore.dataSets || [],
                };
                const optionSetSelectors = storeConfig.dataElements?.map(de => de.selection.optionSet);
                const optionSets = await this.getOptionSets(api, optionSetSelectors || []);

                return { optionSets, custom: storeConfig };
            },
        });

        return new Dhis2DataStoreDataForm(config);
    }

    private static async getOptionSets(api: D2Api, selectors: Selector[]): Promise<OptionSet[]> {
        const ids = _.compact(selectors.map(selector => ("id" in selector ? selector.id : null)));
        const codes = _.compact(selectors.map(selector => ("code" in selector ? selector.code : null)));

        const fields = {
            id: true,
            name: true,
            code: true,
            options: { code: true, displayName: true },
        } as const;

        const res1 = _.isEmpty(ids)
            ? { optionSets: [] }
            : await api.metadata.get({ optionSets: { fields: fields, filter: { id: { in: ids } } } }).getData();

        const res2 = _.isEmpty(codes)
            ? { optionSets: [] }
            : await api.metadata.get({ optionSets: { fields: fields, filter: { code: { in: codes } } } }).getData();

        return _.concat(res1.optionSets, res2.optionSets).map(
            (optionSet): OptionSet => ({
                ...optionSet,
                options: optionSet.options.map(option => ({
                    name: option.displayName,
                    value: option.code,
                })),
            })
        );
    }

    getDataSetConfig(dataSet: CodedRef): DataSetConfig {
        const config = this.config.custom.dataSets.find(dataSetSelector => selectorMatches(dataSet, dataSetSelector));

        const viewType = config?.viewType;

        return {
            texts: {
                header: config?.texts.header || "",
                footer: config?.texts.footer || "",
            },
            viewType: viewType && isElementOfUnion(viewType, DataFormM.viewTypes) ? viewType : "table",
        };
    }

    getDataElementConfig(dataElement: CodedRef): Maybe<DataElementConfig> {
        const dataElementStoreConfig = this.config.custom.dataElements.find(dataElementSelector =>
            selectorMatches(dataElement, dataElementSelector)
        );
        if (!dataElementStoreConfig) return;

        const optionSetSelector = dataElementStoreConfig.selection.optionSet;
        const optionSet = this.config.optionSets.find(optionSet => selectorMatches(optionSet, optionSetSelector));
        if (!optionSet) return;

        return {
            selection: {
                isMultiple: dataElementStoreConfig.selection.isMultiple,
                optionSet,
            },
        };
    }
}

function selectorMatches<T extends { id: string; code: string }>(obj: T, selector: Selector): boolean {
    return "id" in selector ? obj.id === selector.id : obj.code === selector.code;
}

type CodedRef = { id: Id; code: string };
