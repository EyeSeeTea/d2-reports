import _ from "lodash";
import { D2Api } from "@eyeseetea/d2-api/2.34";
import { array, boolean, Codec, GetType, intersect, oneOf, optional, string } from "purify-ts";
import { dataStoreNamespace, Namespaces } from "./clients/storage/Namespaces";
import { isElementOfUnion, Maybe, NonPartial } from "../../utils/ts-utils";
import { Id, NamedRef } from "../../domain/common/entities/Base";
import { Option } from "../../domain/common/entities/DataElement";
import { DataFormM, ViewType } from "../../domain/common/entities/DataForm";

export interface DataSetConfig {
    texts: { header: string; footer: string };
    viewType: ViewType;
    sections: Record<Id, { viewType: ViewType }>;
}

const selector = oneOf([
    Codec.interface({ id: string }),
    Codec.interface({ code: string }), //
]);

function sectionConfig<T extends Record<string, Codec<any>>>(properties: T) {
    return optional(array(intersect(selector, Codec.interface(properties))));
}

const DataStoreConfigCodec = Codec.interface({
    dataElements: sectionConfig({
        selection: Codec.interface({
            optionSet: selector,
            isMultiple: boolean,
        }),
    }),

    dataSets: sectionConfig({
        viewType: optional(string),
        texts: Codec.interface({
            header: optional(string),
            footer: optional(string),
        }),
        sections: sectionConfig({
            viewType: optional(string),
        }),
    }),
});

interface DataElementConfig {
    selection?: {
        optionSet: OptionSet;
        isMultiple: boolean;
    };
}

interface OptionSet extends NamedRef {
    code: string;
    options: Option<string>[];
}

type Selector = GetType<typeof selector>;
type DataFormStoreConfigFromCodec = GetType<typeof DataStoreConfigCodec>;

interface DataFormStoreConfig {
    custom: NonPartial<DataFormStoreConfigFromCodec>;
    optionSets: OptionSet[];
}

const defaultDataStoreConfig: DataFormStoreConfig["custom"] = {
    dataElements: [],
    dataSets: [],
};

interface DataSet {
    id: Id;
    code: string;
    sections: Array<{ id: string; code: string }>;
}

export class Dhis2DataStoreDataForm {
    constructor(private config: DataFormStoreConfig) {}

    static async build(api: D2Api): Promise<Dhis2DataStoreDataForm> {
        const dataStore = api.dataStore(dataStoreNamespace);
        const storeValue = await dataStore.get<object>(Namespaces.AUTOGENERATED_FORMS).getData();
        if (!storeValue) return new Dhis2DataStoreDataForm({ optionSets: [], custom: defaultDataStoreConfig });

        const config: DataFormStoreConfig = await DataStoreConfigCodec.decode(storeValue).caseOf({
            Left: async errorMsg => {
                console.error("Cannot decode autogenerated forms config", {
                    value: storeValue,
                    error: errorMsg,
                });
                return { optionSets: [], custom: defaultDataStoreConfig };
            },
            Right: async storeConfigFromDataStore => {
                const storeConfig: DataFormStoreConfig["custom"] = {
                    dataElements: storeConfigFromDataStore.dataElements || [],
                    dataSets: storeConfigFromDataStore.dataSets || [],
                };
                const optionSetSelectors = storeConfig.dataElements?.map(de => de.selection.optionSet);
                const optionSets = await this.getOptionSets(api, optionSetSelectors || []);

                return { optionSets, custom: storeConfig };
            },
        });

        return new Dhis2DataStoreDataForm(config);
    }

    private static async getOptionSets(api: D2Api, selectors: Selector[]): Promise<OptionSet[]> {
        const ids = _.compact(selectors.map(selector => ("id" in selector ? selector.id : null)));
        const codes = _.compact(selectors.map(selector => ("code" in selector ? selector.code : null)));

        const fields = {
            id: true,
            name: true,
            code: true,
            options: { code: true, displayName: true },
        } as const;

        const resByIds = _.isEmpty(ids)
            ? { optionSets: [] }
            : await api.metadata.get({ optionSets: { fields: fields, filter: { id: { in: ids } } } }).getData();

        const resByCodes = _.isEmpty(codes)
            ? { optionSets: [] }
            : await api.metadata.get({ optionSets: { fields: fields, filter: { code: { in: codes } } } }).getData();

        return _.concat(resByIds.optionSets, resByCodes.optionSets).map(
            (optionSet): OptionSet => ({
                ...optionSet,
                options: optionSet.options.map(option => ({
                    name: option.displayName,
                    value: option.code,
                })),
            })
        );
    }

    getDataSetConfig(dataSet: DataSet): DataSetConfig {
        const config = this.config.custom.dataSets.find(dataSetSelector => {
            return selectorMatches(dataSet, dataSetSelector);
        });

        const viewType = config?.viewType;

        const sections = _(config?.sections)
            .map(sectionConfig => {
                const section = dataSet.sections.find(section => selectorMatches(section, sectionConfig));
                return section
                    ? ([section.id, { viewType: getViewType(sectionConfig.viewType) }] as [Id, { viewType: ViewType }])
                    : undefined;
            })
            .compact()
            .fromPairs()
            .value();

        return {
            texts: {
                header: config?.texts.header || "",
                footer: config?.texts.footer || "",
            },
            viewType: getViewType(viewType),
            sections: sections,
        };
    }

    getDataElementConfig(dataElement: CodedRef): Maybe<DataElementConfig> {
        const dataElementStoreConfig = this.config.custom.dataElements.find(dataElementSelector =>
            selectorMatches(dataElement, dataElementSelector)
        );
        if (!dataElementStoreConfig) return;

        const optionSetSelector = dataElementStoreConfig.selection.optionSet;
        const optionSet = this.config.optionSets.find(optionSet => selectorMatches(optionSet, optionSetSelector));
        if (!optionSet) return;

        return {
            selection: {
                isMultiple: dataElementStoreConfig.selection.isMultiple,
                optionSet,
            },
        };
    }
}

function getViewType(viewType: Maybe<string>): ViewType {
    return viewType && isElementOfUnion(viewType, DataFormM.viewTypes) ? viewType : "table";
}

function selectorMatches<T extends { id: string; code: string }>(obj: T, selector: Selector): boolean {
    return "id" in selector ? obj.id === selector.id : obj.code === selector.code;
}

type CodedRef = { id: Id; code: string };
